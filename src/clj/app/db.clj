(ns app.db
  "
  Data model, with the idea of storing everything in redis

  # Simple stupid idea <- doing this one

  Store article's comments in a hashmap identified by the article id, each
  comment is an entry identified by the comment id and its value is a
  (nippy) serialized map with the following keys:
  - comment-id: string, generated by `nano-id`
  - parent-id: nil or string generated by nano-id
  - section-id: string
  - created-at: string representation of date time (utc)
  - deleted-at: nil or string representation of date time (utc)
  - author: string
  - text: string

  Additionally store a set of known article ids, or articles for which this
  feature is enabled; this to prevent to create comments for articles which
  do not exist. Article ids are simple strings with no specific format,
  it can be a title, a uuid, a whatever...

  # Complex flexible idea

  Resource
  It may represent an article, an image and, in general, something addressable
  with a URI.
  Resources may have sub resources like sections, paragraphs, etc.

  Comments can be attached to resources at any level i.e. top level resources
  like articles or sub (sub) resources like a specific paragraph of a section.

  All the keys will have the prefix bfa (Blog Feedback App).

  Resources will be stored at bfa:resources as a hashmap with the following
  fields:
  - id: identifier of the resources, it can be a uuid, a slugified title, an
    html id
  - uri: uri of the resource
  - mptt: materialized path which is the path from this resource to its
    parent; each part of the path is the id of a resource and is separated by
    a colon, for example: my-awesome-post:abstract:paragraph-2:

  Comments will be stored at bfa:comments as a hashmap with the following
  fields:
  - id: uuid
  - text: string
  - resource-path: mptt pointer to the resource it is attached to
  - parent-id: id of the parent comment
  - created-at: timestamp of the creation date, ISO 8601
  - author: string?, name or id of the author

  To match the early demo, it is expected to have:
  - an article
  - multiple sections of that article (just one level deep)
  - comments and replies attached to a section

  The proposed structure may seem overkill for the problem it is going to
  solve but it is just a fun excercise worth persuing.

  The proposed structure is not enough to efficently query for:
  - all the sections of an article
  - all the comments to an article with a pointer to the specific section
  Plus it would be required to put the comments in the right place in an
  article.
  "
  (:require
   [config.core :as config]
   [nano-id.core :refer [nano-id]]
   [taoensso.carmine :as car :refer [wcar]]
   [taoensso.encore :as enc]))

;; redis spec with connection details is fetched from the global configuration
;; handled by yogthos/config library
(def conn (:redis config/env))

;; Redis schema

;; enabled articles are stored in a set
(def ^:private enabled-articles-key "bfa:enabled-articles-set")

;; article's comments are stored in a hash, one hash for each article
;; this is the prefix for the comments hash key
(def ^:private article-comments-key-prefix "bfa:article-comments:")

(defn- article-comments-key
  "Takes an `article-id` and return the key of the hash containing
   all of its comments."
  [article-id]
  (str article-comments-key-prefix article-id))

(defn enable-article
  "Takes an `article-id` and enable/disable (depending on `enabled` parameter)
  the comment feature for the provided article."
  [article-id enabled]
  (wcar conn
        (if enabled
          (car/sadd enabled-articles-key article-id)
          (car/srem enabled-articles-key article-id))))

(comment
  (enable-article "abcd" true)
  )

(defn uncached-article-enabled?
  "Takes an `article-id` and return `true` if that article is enabled
   or `false` if not.
  "
  [article-id]
  (= 1 (wcar conn (car/sismember enabled-articles-key article-id))))

;; cached/memoized version, keeps the result for 60 seconds
(def article-enabled? (enc/memoize (enc/msecs :secs 60) uncached-article-enabled?))

(comment
  (article-enabled? "abcd") ;; => true
  (article-enabled? "abcd1") ;; => false
  )

(defn disable-all-articles
  "Disables all articles by removing the enabled articles set."
  []
  (wcar conn
    (car/del enabled-articles-key)))

(comment
  (disable-all-articles)
  )

(defn get-enabled-articles
  "Return a vector with all enabled article ids"
  []
  (wcar conn
    (car/smembers enabled-articles-key)))

(comment
  (get-enabled-articles)
  )

(defn- fetch-comments-hash
  [article-comments-key]
  (wcar conn
    (car/hvals article-comments-key)))

(defn get-article-comments
  "Takes an `article-id` and returns a vector with all the comments
   attached to the article."
  [article-id]
  (if (article-enabled? article-id)
    (-> article-id
      article-comments-key
      fetch-comments-hash)
    []))

(comment
  (get-article-comments "abcd")
  )

(defn add-article-comment
  "Takes a `article-id` and a map representing a comment and add the
  comment to the datastore.
  The keys `comment-id` and `parent-id` (when present), are strings
  generated with `nano-id` library.
  `parent-id` should point to an existing `comment-id` but there are no
  checks to ensure this condition.
  "
  [article-id
   {:keys [comment-id section-id author created-at deleted-at text parent-id]
    :or
    {comment-id (nano-id 10)
     author     "Anonymous coward"
     created-at (java.time.LocalDateTime/now)}}]
  (when (article-enabled? article-id)
    (let [comment {:comment-id (str comment-id)
                   :section-id section-id
                   :author     author
                   :created-at (str created-at)
                   :deleted-at (str deleted-at)
                   :text       text
                   :parent-id  parent-id}]
      (wcar conn
            (car/hmset (article-comments-key article-id)
                       comment-id comment))
      comment)))

(comment
  (add-article-comment "abcd" {:section-id "section-1"
                               :author     "someone"
                               :text       "a beautyful comment"})

  (add-article-comment "abcd" {:section-id "section-2"
                               :author     "someone"
                               :text       "a beautyful comment"})

  (add-article-comment "abcd" {:section-id "section-3"
                               :author     "someone"
                               :text       "a comment with children"})

  (add-article-comment "abcd" {:section-id "section-3"
                               :author     "someonelse"
                               :text       "a comment with parent"
                               :parent-id (-> "abcd"
                                              get-article-comments
                                              first
                                              :comment-id)}))

(defn- delete-comments-hash
  [article-comments-key]
  (wcar conn (car/del article-comments-key)))

(defn delete-article-comments
  "Takes an `article-id` and deletes all of its the comments."
  [article-id]
  (-> article-id
       article-comments-key
       delete-comments-hash))

(comment
  (delete-article-comments "abcd")
  )

(defn- delete-single-comment
  [article-comments-key comment-id]
  (wcar conn (car/hdel article-comments-key comment-id)))

(defn delete-single-article-comment
  "Takes an `article-id` and `comment-id` and deletes the specified comment
  of the article."
  [article-id comment-id]
  (-> article-id
      article-comments-key
      (delete-single-comment comment-id)))

(comment
  ;; be sure to have at least one comment for the article :)
  (delete-single-article-comment "abcd" (-> "abcd"
                                          get-article-comments
                                          first
                                          :comment-id))
  )
